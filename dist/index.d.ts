// Generated by dts-bundle-generator v8.1.2

export type WalletNetwork = "livenet" | "testnet";
export type Balance = {
	confirmed: number;
	unconfirmed: number;
	total: number;
};
export interface BtcWalletConnectOptions {
	network?: BrcWalletNetwork;
	defaultConnectorId?: BtcConnectorId;
}
export type BrcWalletNetwork = "livenet" | "testnet";
export type BtcConnectorId = "unisat" | "okx";
export type AccountsChangedEvent = (event: "networkChanged", handler: (accounts: Array<string>) => void) => void;
export type NetworkChangedEvent = (event: "networkChanged", handler: (network: BrcWalletNetwork) => void) => void;
export type MessageType = "ecdsa" | "bip322-simple";
export type Address = string;
declare abstract class BtcConnector {
	/** Unique connector id */
	abstract readonly id: string;
	/** Connector name */
	abstract readonly name: string;
	/** Extension or Snap homepage */
	abstract homepage: string;
	/** Whether connector is usable */
	ready: boolean;
	installed: boolean;
	connected: boolean;
	address: Address | undefined;
	publicKey: string | undefined;
	network: WalletNetwork;
	constructor(network: WalletNetwork);
	abstract connect(): Promise<boolean>;
	abstract sendToAddress(toAddress: string, amount: number): Promise<string>;
	abstract signPsbt(psbtHex: string, options?: any): Promise<string>;
	disconnect(): void;
	getAccount(): string | undefined;
	isAuthorized(): boolean;
	getNetwork(): Promise<WalletNetwork>;
	getPublicKey(): Promise<string>;
}
declare namespace UnisatWalletTypes {
	type AccountsChangedEvent = (event: "accountsChanged" | "networkChanged", handler: (accounts: Array<string> | string) => void) => void;
	type Inscription = {
		inscriptionId: string;
		inscriptionNumber: string;
		address: string;
		outputValue: string;
		content: string;
		contentLength: string;
		contentType: string;
		preview: string;
		timestamp: number;
		offset: number;
		genesisTransaction: string;
		location: string;
	};
	type GetInscriptionsResult = {
		total: number;
		list: Inscription[];
	};
	type SendInscriptionsResult = {
		txid: string;
	};
	type Network = "livenet" | "testnet";
}
export type Unisat = {
	requestAccounts: () => Promise<string[]>;
	getAccounts: () => Promise<string[]>;
	on: UnisatWalletTypes.AccountsChangedEvent;
	removeListener: UnisatWalletTypes.AccountsChangedEvent;
	getInscriptions: (cursor: number, size: number) => Promise<UnisatWalletTypes.GetInscriptionsResult>;
	sendInscription: (address: string, inscriptionId: string, options?: {
		feeRate: number;
	}) => Promise<UnisatWalletTypes.SendInscriptionsResult>;
	switchNetwork: (network: "livenet" | "testnet") => Promise<void>;
	getNetwork: () => Promise<UnisatWalletTypes.Network>;
	getPublicKey: () => Promise<string>;
	getBalance: () => Promise<Balance>;
	sendBitcoin: (address: string, atomicAmount: number, options?: {
		feeRate: number;
	}) => Promise<string>;
	pushTx: ({ rawtx }: {
		rawtx: string;
	}) => Promise<string>;
	pushPsbt: (psbtHex: string) => Promise<string>;
	signMessage: (message: string, type?: "ecdsa" | "bip322-simple") => Promise<string>;
	signPsbt: (psbtHex: string, options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		}[];
	}) => Promise<string>;
	signPsbts: (psbtHexs: string[], options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		};
	}[]) => Promise<string[]>;
};
declare class UnisatConnector extends BtcConnector {
	readonly id = "unisat";
	readonly name = "Unisat";
	homepage: string;
	banance: Balance;
	unisat: Unisat;
	constructor(network: WalletNetwork);
	on(event: "accountsChanged" | "networkChanged", handler: any): void;
	removeListener(event: "accountsChanged" | "networkChanged", handler: any): void;
	connect(): Promise<boolean>;
	getCurrentInfo(): Promise<void>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	switchNetwork(network: WalletNetwork): Promise<void>;
	getPublicKey(): Promise<string>;
	getBalance(): Promise<Balance>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signMessage(message: string): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
}
declare namespace OkxWalletTypes {
	interface AddressInfo {
		address: string;
		publicKey: string;
		compressedPublicKey: string;
	}
	type OnEvent = (event: "accountsChanged" | "accountChanged", handler: (accounts: Array<string> | Array<AddressInfo>) => void) => void;
	type Inscription = {
		inscriptionId: string;
		inscriptionNumber: string;
		address: string;
		outputValue: string;
		content: string;
		contentLength: string;
		contentType: string;
		preview: string;
		timestamp: number;
		offset: number;
		genesisTransaction: string;
		location: string;
	};
	type GetInscriptionsResult = {
		total: number;
		list: Inscription[];
	};
	type Network = "livenet" | "testnet";
	interface ConnectResult {
		address: string;
		publicKey: string;
	}
	interface SendProps {
		from: string;
		to: string;
		value: number;
		satBytes: number;
	}
	interface SendResult {
		txhash: string;
	}
	interface TransferNftProps {
		from: string;
		to: string;
		data: string | string[];
	}
	interface TransferNftResult {
		txhash: string;
	}
	interface SplitUtxoProps {
		from: string;
		amount: number;
	}
	interface SplitUtxoResult {
		utxos: {
			txId: string;
			vOut: number;
			amount: number;
			rawTransaction: string;
		}[];
	}
	interface InscribeProps {
		type: 51 | 58;
		from: string;
		tick: string;
		tid: string;
	}
	interface MintProps {
		type: 60 | 50 | 51 | 62 | 61 | 36 | 33 | 34 | 35 | 58;
		from: string;
		inscriptions: {
			contentType: string;
			body: string;
		}[];
	}
	interface MintResult {
		commitAddrs: string[];
		commitTx: string;
		revealTxs: string[];
		commitTxFee: number;
		revealTxFees: number[];
		feeRate: number;
		size: number;
	}
}
export type OkxWallet = {
	connect: () => Promise<OkxWalletTypes.ConnectResult>;
	requestAccounts: () => Promise<string[]>;
	getAccounts: () => Promise<string[]>;
	getNetwork: () => Promise<OkxWalletTypes.Network>;
	getPublicKey: () => Promise<string>;
	getBalance: () => Promise<Balance>;
	getInscriptions: (cursor: number, size: number) => Promise<OkxWalletTypes.GetInscriptionsResult>;
	sendBitcoin: (toAddress: string, satoshis: number, options?: {
		feeRate: number;
	}) => Promise<string>;
	sendInscription: (address: string, inscriptionId: string, options?: {
		feeRate: number;
	}) => Promise<string>;
	transferNft: ({ from, to, data, }: OkxWalletTypes.TransferNftProps) => Promise<OkxWalletTypes.TransferNftResult>;
	send: ({ from, to, value, satBytes }: OkxWalletTypes.SendProps) => Promise<OkxWalletTypes.SendResult>;
	signMessage: (message: string, type?: "ecdsa" | "bip322-simple") => Promise<string>;
	pushTx: (rawtx: string) => Promise<string>;
	splitUtxo: ({ from, amount }: OkxWalletTypes.SplitUtxoProps) => Promise<OkxWalletTypes.SplitUtxoResult>;
	inscribe: ({ type, from, tick, tid }: OkxWalletTypes.InscribeProps) => Promise<string>;
	mint: ({ type, from, inscriptions }: OkxWalletTypes.MintProps) => Promise<OkxWalletTypes.MintResult>;
	signPsbt: (psbtHex: string, options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		}[];
	}) => Promise<string>;
	signPsbts: (psbtHexs: string[], options?: {
		autoFinalized?: boolean;
		toSignInputs: {
			index: number;
			address?: string;
			publicKey?: string;
			sighashTypes?: number[];
			disableTweakSigner?: boolean;
		};
	}[]) => Promise<string[]>;
	pushPsbt: (psbtHex: string) => Promise<string>;
	on: OkxWalletTypes.OnEvent;
};
declare class OkxConnector extends BtcConnector {
	readonly id = "okx";
	readonly name = "Okx Wallet";
	homepage: string;
	banance: Balance;
	okxwallet: OkxWallet;
	constructor(network: WalletNetwork);
	on(event: "accountsChanged" | "accountChanged", handler: any): void;
	connect(): Promise<boolean>;
	getCurrentInfo(): Promise<void>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	getNetwork(): Promise<WalletNetwork>;
	getPublicKey(): Promise<string>;
	getBalance(): Promise<Balance>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	switchNetwork(network: WalletNetwork): Promise<void>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signMessage(message: string): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
}
export type Connector = UnisatConnector | OkxConnector;
export interface BtcConnectors {
	id: string;
	instance: Connector;
	installed: boolean;
}
declare class BtcWalletConnect {
	private local_storage_key;
	connectorId: BtcConnectorId;
	localConnectorId?: BtcConnectorId;
	connected: boolean;
	installed: boolean;
	address?: string;
	publicKey?: string;
	network: BrcWalletNetwork;
	balance: Balance;
	connectors: BtcConnectors[];
	connector?: Connector;
	constructor({ network, defaultConnectorId, }: BtcWalletConnectOptions);
	switchConnector(id: BtcConnectorId): Promise<Connector>;
	connect(): Promise<boolean>;
	private getCurrentInfo;
	check(): Promise<void>;
	disconnect(): Promise<void>;
	getAccounts(): Promise<string[]>;
	getNetwork(): Promise<WalletNetwork>;
	switchNetwork(network: BrcWalletNetwork): Promise<void>;
	sendToAddress(toAddress: string, amount: number): Promise<string>;
	signMessage(message: string, type?: MessageType): Promise<string>;
	signPsbt(psbtHex: string, options?: any): Promise<string>;
	signPsbts(psbtHexs: string[], options?: any): Promise<string[]>;
	pushTx(rawTx: string): Promise<string>;
	pushPsbt(psbtHex: string): Promise<string>;
	on: NetworkChangedEvent | AccountsChangedEvent;
	removeListener: NetworkChangedEvent | AccountsChangedEvent;
}

export {
	BtcWalletConnect as default,
};

export {};
